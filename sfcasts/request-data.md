# Fancy new Ways to Grab Request Data

Coming soon...

The next new stuff I want to talk about are related to how we fetch data from the request. That's normally kind of boring work, but the new features are pretty darn cool. For example, let's add a ?query="banana") to the URL. To fetch that in our controller, we would historically type in an argument with request and fetch it from there. And while that still works, we can now add a ?string="query-argument". To tell Symfony that this is something that comes off of a query parameter, we add an attribute in front of it called ?map-query-parameter. And that's it. Inside, I'll dump query to make sure that works. Back over here, we refresh. In the Web Depot toolbar, we've got it. And that's all you need to do. There are options that you can configure on here. So, for example, if your query parameter was called something else, you could put that there. But if your query parameter has the same name as your argument, you don't need any config. And beyond just grabbing this value from the request, it's also performing validation. Watch. Let's duplicate this and make a page="1-argument". And I'm actually going to make the query optional also so that we don't have to have a query parameter on the URL. Then down here, I will dump page. No surprise if we say, for example, page="3", it dumps three. And it is nice that it is giving us a true integer three, not a string three. But there's even more to that type int. If I change this to page="banana", it fails. And it fails the right way. We get a 404. The system sees we have an int type and performs validation on that. Now, this entire system is handled by something called the Query Parameter Value Resolver. So if you really want to dig in and see how things are working, you can check that class. But internally, that class is using a PHP function called FilterVar to do the validation. This is not a function that I was very familiar with before. It's incredibly powerful. We're not going to go too deep into it. But on a high level, you pass it a value, you pass it one or more filters, and it tells you whether that value passes those filters. You can also pass options to control those filters.  If you don't do anything else, the system is going to read our type int, and it's going to determine a filter. It's going to pass a filter here that's going to require this to be an int. So that is ultimately why this is failing. But we can get fancier with this. For example, let's add another one called Limit. And I'm going to set this, default this to 10. Let's dump it down here. However, in this case, I want the limit to be between 1 and 10. So to do that, the FilterVar function takes options. There's an option called Minimize. There's an option called MinRange, which we can set to 1. MaxRange, which we can set to 10. And that should do it. Back over here, I'll say limit equals 3. And that works like we expect. But if I say limit equals 13, the FilterVar fails. We get a 404, which is awesome. The MapQuery parameter can even handle arrays. So let's copy and create one more query parameter here, an array of filters. Default it to an empty array. Let's dump that. And now over here, we can use the format ?filters, left square bracket, right square bracket equals banana, and filters, bracket, bracket equals apple. And when we do that, we get the array down in the WebDebugToolbar. And it also works for associative arrays. So if I put foo and a bar between the square brackets, yeah, we get an associative array. So just a really well-designed feature for fetching query parameters. In addition to this, if you need to fetch the body of a request, in Symfony 6.3, there's a new method called request getPayload. And this says two different things. If you're building an API and your client is sending JSON in the body, requestErrorGetPayload is going to decode that JSON into an associative array for you, which is nice. But also, if your user is submitting a normal HTML form, requestGetPayload works for that as well. It's going to detect that there's a HTML form being submitted. It's going to decode it. It's going to give you an array. So no matter if you're using an API or normal form, you have one uniform method to fetch the payload on the request, which is just nice.  Now, speaking of the JSON example, a lot of times if you are handling JSON as an input, you're going to want to deserialize that into an object. So that relates to another feature called MapRequestPayload. So in this case, invoke is actually our controller. And what this says is take the JSON of the request and deserialize it into a product review DTO, which is this example class up here. So it's going to send that through the serializer, deserialize it. It's also going to perform validation on it. So just another well thought out feature. All right. That's enough for request stuff. Next up, let's dive into a brand new feature for Symfony 6.4 where we can actually profile and use Symfony's profiler on console commands.
