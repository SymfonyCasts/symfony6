WEBVTT

00:00:01.156 --> 00:00:05.626 align:middle
Uno de los componentes nuevos más interesantes
es Scheduler, que viene de Symfony 6.3.

00:00:06.156 --> 00:00:10.176 align:middle
Si necesitas activar una tarea recurrente,
como generar un informe semanal,

00:00:10.426 --> 00:00:14.596 align:middle
enviar algún tipo de latido cada 10 minutos,
realizar un mantenimiento rutinario...

00:00:14.816 --> 00:00:18.356 align:middle
o incluso algo personalizado y
extraño, este componente es para ti.

00:00:18.796 --> 00:00:20.026 align:middle
¡Es realmente genial!

00:00:20.586 --> 00:00:23.566 align:middle
Merece su propio tutorial, pero nos
preocuparemos de eso más adelante.

00:00:24.086 --> 00:00:25.416 align:middle
Vamos a probarlo.

00:00:26.036 --> 00:00:28.066 align:middle
En tu línea de comandos, instálalo con:

00:00:28.186 --> 00:00:33.436 align:middle
composer require symfony/scheduler
symfony/messenger Scheduler se

00:00:33.436 --> 00:00:35.466 align:middle
apoya en Messenger: ¡trabajan juntos!

00:00:36.016 --> 00:00:37.546 align:middle
El proceso es el siguiente.

00:00:37.956 --> 00:00:41.706 align:middle
Creas una clase de mensaje y un manejador,
como harías normalmente con Messenger.

00:00:42.226 --> 00:00:44.336 align:middle
Luego le dices a Symfony ¡Eh!

00:00:44.626 --> 00:00:50.536 align:middle
Quiero que envíes este mensaje para que se
gestione cada siete días, o cada una hora...

00:00:50.806 --> 00:00:51.996 align:middle
o algo más raro.

00:00:52.616 --> 00:00:55.726 align:middle
Esto significa que el primer paso
es generar un mensaje de Messenger.

00:00:56.256 --> 00:01:00.336 align:middle
Ejecuta: php bin/console
make:message Llámalo LogHello.

00:01:01.346 --> 00:01:07.496 align:middle
¡Genial! Aquí, crea la clase de
mensaje - LogHello y su manejador,

00:01:07.686 --> 00:01:13.536 align:middle
cuyo método __invoke() será llamado cuando
LogHello se envíe a través de Messenger.

00:01:14.186 --> 00:01:18.326 align:middle
En LogHello, dale un constructor
con public int $length.

00:01:18.956 --> 00:01:22.166 align:middle
Esto nos ayudará a saber qué mensaje
se está gestionando y cuándo.

00:01:22.866 --> 00:01:28.196 align:middle
En el manejador, añade también un constructor para
que podamos autocablear LoggerInterface $logger.

00:01:29.656 --> 00:01:35.256 align:middle
Abajo en el método, utiliza $this->logger->warning()
-sólo para que estas entradas de registro sean fáciles de ver-

00:01:35.556 --> 00:01:40.936 align:middle
y luego str_repeat() para registrar un
icono de guitarra $message->length veces.

00:01:41.696 --> 00:01:43.556 align:middle
También registraré ese número al final.

00:01:45.016 --> 00:01:46.896 align:middle
Comprobación de mensajes y manejadores

00:01:47.586 --> 00:01:51.756 align:middle
Lo siguiente es crear una programación
que le diga a Symfony: Yo, yo otra vez.

00:01:52.056 --> 00:01:56.836 align:middle
Por favor, envía un mensaje LogHello
a través de Messenger cada 7 días.

00:01:57.196 --> 00:02:00.956 align:middle
O en nuestro caso, cada pocos
segundos, ¡porque no creo que quieras

00:02:00.956 --> 00:02:03.046 align:middle
ver este screencast durante la próxima semana!

00:02:03.656 --> 00:02:08.096 align:middle
En src/, no tengo que hacer esto,
pero crearé un directorio Scheduler.

00:02:08.746 --> 00:02:12.606 align:middle
Y dentro, una clase PHP
llamada, qué tal, MainSchedule.

00:02:14.316 --> 00:02:16.956 align:middle
Haz que esto implemente
ScheduleProviderInterface.

00:02:17.506 --> 00:02:21.036 align:middle
Puedes tener varios de estos
proveedores de horarios en tu sistema...

00:02:21.376 --> 00:02:25.196 align:middle
o puedes tener una clase que configure
todos tus mensajes recurrentes.

00:02:25.516 --> 00:02:26.166 align:middle
Tú decides.

00:02:27.026 --> 00:02:29.996 align:middle
Esta clase también necesita un
atributo llamado #[AsSchedule].

00:02:30.616 --> 00:02:37.546 align:middle
Tiene un argumento opcional: el nombre de la
programación, que, creativamente, es por defecto default.

00:02:38.156 --> 00:02:40.226 align:middle
Pronto veremos por qué
es importante ese nombre.

00:02:40.806 --> 00:02:41.846 align:middle
Yo utilizaré default.

00:02:42.676 --> 00:02:45.266 align:middle
Bien, ve a Código ->
Generar, o comando+N en un Mac -

00:02:45.426 --> 00:02:48.566 align:middle
para implementar el único método
que necesitamos: getSchedule().

00:02:49.326 --> 00:02:52.476 align:middle
El código que hay aquí es
maravillosamente sencillo y expresivo.

00:02:52.986 --> 00:02:57.366 align:middle
Devuelve un new Schedule(), luego añade
cosas a éste llamando a ->add().

00:02:58.146 --> 00:03:02.286 align:middle
Dentro, por cada "cosa" que necesites
programar, di RecurringMessage::.

00:03:02.286 --> 00:03:06.906 align:middle
Hay varias formas de crear
estos mensajes recurrentes.

00:03:07.386 --> 00:03:11.876 align:middle
La más sencilla es every(), como
cada 7 days o cada 5 minutes.

00:03:12.486 --> 00:03:15.796 align:middle
También puedes pasar una sintaxis
cron, o llamar a trigger().

00:03:16.286 --> 00:03:20.006 align:middle
En ese caso, definirías tu propia
lógica para saber exactamente

00:03:20.006 --> 00:03:22.396 align:middle
cuándo quieres que se active tu mensaje raro.

00:03:23.016 --> 00:03:25.196 align:middle
Utiliza every() y pasa 4 seconds.

00:03:25.766 --> 00:03:30.966 align:middle
Cada 4 segundos, queremos que este nuevo
mensaje LogHello se envíe a Messenger.

00:03:31.516 --> 00:03:34.806 align:middle
Cópialo y crea otro para cada 3 seconds.

00:03:37.146 --> 00:03:38.166 align:middle
¡Ya hemos terminado!

00:03:38.616 --> 00:03:43.926 align:middle
El resultado de crear un proveedor de programación
es que se crea un nuevo transporte a Messenger.

00:03:44.616 --> 00:03:46.896 align:middle
Para que tus mensajes recurrentes se procesen,

00:03:47.216 --> 00:03:51.236 align:middle
necesitas tener un trabajador que
ejecute el comando messenger:consume.

00:03:51.896 --> 00:03:56.076 align:middle
En tu terminal, ejecuta bin/console
messenger:consume con un -v

00:03:56.186 --> 00:03:59.286 align:middle
para que podamos ver los mensajes
de registro de nuestro manejador.

00:03:59.696 --> 00:04:01.256 align:middle
A continuación, pasa el nombre del nuevo

00:04:01.376 --> 00:04:05.566 align:middle
transporte añadido automáticamente:
scheduler_default...

00:04:05.826 --> 00:04:09.876 align:middle
donde default es el nombre que
utilizamos en el atributo #[AsSchedule].

00:04:10.456 --> 00:04:12.886 align:middle
Dale, espera unos 3 segundos...

00:04:13.996 --> 00:04:14.766 align:middle
¡ya está!

00:04:15.026 --> 00:04:20.086 align:middle
¡Cuatro! Luego vuelve a aparecer
el 3, y cuatro, y luego tres.

00:04:20.646 --> 00:04:26.476 align:middle
Al cabo de 12 segundos, deberían
ejecutarse, sí, casi en el mismo momento.

00:04:26.856 --> 00:04:32.326 align:middle
Técnicamente, éste se despachó primero, y
aquél se despachó inmediatamente después.

00:04:32.826 --> 00:04:36.736 align:middle
Pero, permíteme que deje de
flipar y retroceda: ¡funciona!

00:04:37.136 --> 00:04:38.366 align:middle
¡Es precioso!

00:04:38.816 --> 00:04:40.056 align:middle
¿Cómo funciona?

00:04:40.586 --> 00:04:42.366 align:middle
Eso mismo me preguntaba yo.

00:04:42.956 --> 00:04:47.246 align:middle
Cuando se inicia el comando trabajador,
recorre cada RecurringMessage,

00:04:47.496 --> 00:04:52.396 align:middle
calcula el próximo tiempo de ejecución de
cada uno y lo utiliza para crear una lista

00:04:52.556 --> 00:04:55.426 align:middle
-llamada "montón"- de los próximos mensajes.

00:04:55.916 --> 00:04:57.806 align:middle
A continuación, realiza un
bucle sin fin. En cuanto la

00:04:58.426 --> 00:05:03.256 align:middle
hora actual coincide -o es posterior-
al tiempo de ejecución programado

00:05:03.256 --> 00:05:08.336 align:middle
del siguiente mensaje de la pila, toma ese
mensaje y lo envía a través de Messenger.

00:05:08.936 --> 00:05:14.966 align:middle
A continuación, pide a este mensaje recurrente su
siguiente tiempo de ejecución y lo coloca en el montón.

00:05:15.476 --> 00:05:16.426 align:middle
Y este proceso...

00:05:16.596 --> 00:05:18.036 align:middle
continúa para siempre.

00:05:18.426 --> 00:05:23.236 align:middle
Aunque hay un problema que se esconde a
plena vista: si reiniciamos el comando,

00:05:23.506 --> 00:05:25.716 align:middle
crea la programación desde cero.

00:05:26.116 --> 00:05:28.726 align:middle
Eso significa que espera tres
segundos y cuatro segundos nuevos

00:05:28.726 --> 00:05:31.656 align:middle
antes de enviar los mensajes.

00:05:32.256 --> 00:05:35.436 align:middle
En una aplicación real,
esto será un problema.

00:05:36.056 --> 00:05:39.406 align:middle
Imagina que tienes un mensaje
que se ejecuta cada 7 días. Por

00:05:39.806 --> 00:05:41.936 align:middle
alguna razón, al cabo de 5 días,

00:05:42.196 --> 00:05:45.466 align:middle
tu comando messenger:consume
sale y se reinicia. Debido a

00:05:46.046 --> 00:05:49.546 align:middle
esto, tu mensaje recurrente se
ejecutará ahora siete días

00:05:49.706 --> 00:05:53.886 align:middle
después de este reinicio: así
que se ejecutará el día 12.

00:05:53.886 --> 00:05:57.896 align:middle
Si se sigue reiniciando, ¡puede
que tu mensaje no se ejecute nunca!

00:05:58.316 --> 00:05:59.756 align:middle
Esto no es factible.

00:06:00.256 --> 00:06:04.866 align:middle
Por eso, en el mundo real, siempre hacemos
que nuestra programación tenga estado.

00:06:05.246 --> 00:06:06.366 align:middle
Y esto es fácil.

00:06:07.066 --> 00:06:10.666 align:middle
Crea un método __construct y
autoconecta un private CacheInterface:

00:06:10.956 --> 00:06:12.376 align:middle
el de la caché de Symfony.

00:06:13.846 --> 00:06:17.796 align:middle
A continuación, llama a ->stateful()
y pásale $this->cache.

00:06:18.496 --> 00:06:20.396 align:middle
Además, abre services.yaml.

00:06:20.916 --> 00:06:23.756 align:middle
En un tutorial anterior,
añadí alguna configuración

00:06:23.756 --> 00:06:27.146 align:middle
que desactivaba efectivamente
la caché en el entorno dev.

00:06:27.786 --> 00:06:30.206 align:middle
Elimínalo para que tengamos
una caché adecuada.

00:06:30.866 --> 00:06:32.906 align:middle
Bien, detén el trabajador y reinícialo.

00:06:33.456 --> 00:06:37.166 align:middle
La primera vez que hagamos esto, tendrá
el mismo comportamiento que antes:

00:06:37.386 --> 00:06:39.656 align:middle
espera tres segundos y cuatro segundos.

00:06:39.926 --> 00:06:40.516 align:middle
Ya está.

00:06:41.106 --> 00:06:46.346 align:middle
Pero ahora, detén esto, espera unos segundos
y observa lo que ocurre cuando reinicie.

00:06:47.066 --> 00:06:48.116 align:middle
¡Se pone al día!

00:06:48.516 --> 00:06:50.896 align:middle
¡Esos mensajes ocurrieron inmediatamente!

00:06:51.366 --> 00:06:55.306 align:middle
El estado lleva la cuenta de la última vez que
el Programador comprobó si había mensajes.

00:06:55.646 --> 00:07:01.796 align:middle
Y así, si tu trabajador se apaga un
rato, cuando se reinicia, lee esa hora

00:07:01.956 --> 00:07:06.926 align:middle
y la utiliza como hora de inicio para ponerse
al día con todos los mensajes que se perdió.

00:07:07.496 --> 00:07:09.636 align:middle
Esto significa que puedes
tener algunos mensajes

00:07:09.636 --> 00:07:13.896 align:middle
que se ejecuten varias veces
inmediatamente, pero no se perderá nada.

00:07:14.496 --> 00:07:17.976 align:middle
Ah, y si piensas tener varios trabajadores
para tu transporte programador,

00:07:18.356 --> 00:07:20.726 align:middle
también tendrás que añadir
un bloqueo a la programación.

00:07:21.296 --> 00:07:25.296 align:middle
Esto es fácil y está cubierto en los
documentos: autocablea la fábrica de bloqueos,

00:07:25.726 --> 00:07:28.896 align:middle
luego llama a ->lock()
para pasar un nuevo bloqueo.

00:07:29.516 --> 00:07:33.516 align:middle
Esto asegurará que dos trabajadores
no cojan el mismo mensaje recurrente

00:07:33.516 --> 00:07:35.946 align:middle
al mismo tiempo y ambos lo procesen.

00:07:36.756 --> 00:07:38.766 align:middle
Muy bien equipo, ¡eso es todo lo que tengo!

00:07:39.186 --> 00:07:40.596 align:middle
Gracias por esperar.

00:07:41.106 --> 00:07:45.266 align:middle
Si tienes alguna pregunta sobre la actualización o te has
encontrado con algún problema que no hayamos mencionado, estamos

00:07:45.526 --> 00:07:47.386 align:middle
a tu disposición en los comentarios.

00:07:47.776 --> 00:07:51.186 align:middle
Y avísanos si consigues una victoria:
nos encanta escuchar éxitos.

00:07:51.756 --> 00:07:52.396 align:middle
Muy bien, amigos.

00:07:52.606 --> 00:07:53.276 align:middle
¡Hasta la próxima!
